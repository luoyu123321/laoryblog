谈谈你对闭包的理解
定义：
红宝书(p178)上对于闭包的定义：闭包是指有权访问另外一个函数作用域中的变量的函数，MDN 对闭包的定义为：闭包是指那些能够访问自由变量的函数。（其中自由变量，指在函数中使用的，但既不是函数参数arguments也不是函数的局部变量的变量，其实就是另外一个函数作用域中的变量。）
闭包不是一个单一概念，它包含多个知识点
	
	作用域（链）、执行上下文、内存管理等
	作用域和作用域链： 
作用域是一套规则，用于确定在场景下如何查找变量。 Es6之前只有函数作用域和全局作用域之分。
			在js执行一段函数时，遇见变量读取其值，会就近在函数内部找该变量的声明或者赋值情况。如果函数内无法找到该变量，就要跳出函数作用域，到更上层作用域查找，更上层的作用域也可能是函数作用域。
		作用域链; 变量作用域的查找是一个扩散的过程，就像各环节相扣的链条，逐次递进
		块级作用域和暂时性死区
		Es6增加了let和const声明变量的块级作用域。块级作用域，顾名思义，作用域限制在代码块中
		暂时性死区：当使用let和const声明变量，会针对这个变量形成一个封闭的块级作用域，在这个块级作用域中，如果在声明变量前访问该变量，就会报referenceerror错误。
执行上下文
	执行环境定义了变量或函数有权访问的其它数据，决定了他们各自的行为。每个执行环境都有一个与之关联的变量对象（variable object）,环境中定义的所有变量和函数都保存在这个对象中。虽然我们编写的代码无法访问这个对象，但解析器在处理数据时会在后台使用它。
	全局执行环境是最外围的一个执行环境，在web浏览器中，被认为是window对象。
	代码执行的两个阶段
	代码预编译阶段和代码执行阶段
	代码预编译阶段
	是前置阶段，这个时候由编译器将javascript代码编译成可执行的代码；
	注意，这里的预编译和传统的编译并不一样，传统编译很复杂，涉及分词、解析、代码生成。这里的预编译是js独特的概念。
执行阶段
	执行阶段主要任务是执行代码，执行上下文在这个阶段全部创建完成
	当代码在一个环境中执行是，会创建变量对象的一个作用域链（scope chain）；
	作用域链的用途保证对执行环境有权访问的所有变量和函数的有权访问。作用域链的前端，始终都是当前执行的代码所在环境的变量对象。如果这个环境是函数，则将其活动对象（action object）作为变量对象，作用域链的下一个变量对象来自包含（外部）环境，一直延续到全局执行环境，全局执行环境的变量对象始终都是作用域链的最后一个对象。
	
总结：
作用域是在预编译阶段确定，但是作用域链是在执行上下文创建阶段完全生成的。因为函数在调用时，才会开始创建对应的执行上下文。执行上下文包括：变量对象、作用域链以及this指向

内存管理
	内存空间分为栈空间和堆空间
	栈空间： 由操作系统自动分配释放，存放函数的参数值，局部变量的值等，其操作空间类似于数据结构中的栈。jS中的基础数据类型，这些值都有固定的大小，往往都保存在栈内存中（闭包除外），由系统自动分配存储空间
	堆空间： 一般由开发者分配释放，这部分就要考虑垃圾回收的问题。
	内存的生命周期
	内存分配 =》使用内存 =》 释放内存
	内存分配： 当我们申明变量、函数、对象的时候，系统会自动为他们分配内存
	内存使用： 即读写内存，也就是使用变量、函数等
	内存回收： 使用完毕，由垃圾回收机制自动回收不再使用的内存
	对应内存的分配和读写行为所有语言较为一致，但释放内存空间在不太语言之间有差异。Js依赖宿主浏览器的垃圾回收机制
js垃圾回收机制
	引用计数法
	标记清除法
闭包的常见表现形式
	最常用的一种形式是函数作为返回值被返回
函数参数传递
var a = 1;
function foo(){
  var a = 2;
  function baz(){
    console.log(a);
  }
  bar(baz);
}
function bar(fn){
  // 这就是闭包
  fn();
}
// 输出2，而不是1
foo();
	
在定时器、事件监听、Ajax请求、跨窗口通信、Web Workers或者任何异步中，只要使用了回调函数，实际上就是在使用闭包	
立即执行函数表达式IIFE + 闭包
function makeFunctionArray(){
  const arr = [];
  for(var i = 0; i < 5; i++) {
    arr.push((function(a) {
      return function(){console.log(a);}
    })(i));
  }
  console.log(i);       //5
  return arr;
}
const arr = makeFunctionArray();
arr[0]();        //0
arr[1]();        //1
内存泄漏
	指内存空间明明已经不再被使用，但由于某种原因没有被释放的现象，它会直接导致程序运行缓慢甚至崩溃
闭包
常见内存泄漏的情况
意外使用全局变量，比如函数内部使用全局变量：
监听事件的解除，监听的时候addEventListener，在不监听的时候要使用remveEventListener
定时器，定时器不清除，一直占用内存，得不到释放，或者在定时器内调用外部函数，得不到释放
 如果使用 setInterval，那么它引用到的变量的上下文会保留下来
不用为了仅仅避免内存泄露对 setTimeout 调用 clearTimeout 。它是不会造成内存泄露的，除非是别的什么原因，比如说，在 setTimeout 中递归调用了当前定时器，这相当于模拟 setInterval，可以与 setInterval 做类似处理。
DOM 事件
当页面中元素被移除或替换时，若元素绑定的事件仍没被移除，在IE中不会作出恰当处理，此时要先手工移除事件，不然会存在内存泄露
var content = document.getElementById('content');
content.innerHTML = '<button id="button">click</button>';

var button = document.getElementById('button');
button.addEventListener('click', function() {});

content.innerHTML = '';

这段代码过后，虽然 <button> 从 DOM 中移除了，由于它的监听器还在，所以无法被 GC 回收。
要避免这种情况就是通过 removeEventListener 将回调函数去掉。
循环引用
var a=document.getElementById("xx");var b=document.getElementById("xxx");a.r=b;b.r=a;
或
var a=document.getElementById("xx");
a.r=a;
对于纯粹的 ECMAScript 对象而言，只要没有其他对象引用对象 a、b，也就是说它们只是相互之间的引用，那么仍然会被垃圾收集系统识别并处理。但是，在 Internet Explorer 中（老的 IE 6 是无法处理循环引用的），如果循环引用中的任何对象是 DOM 节点或者 ActiveX 对象，垃圾收集系统则不会发现它们之间的循环关系与系统中的其他对象是隔离的并释放它们。最终它们将被保留在内存中，直到浏览器关闭
闭包
闭包可以维持函数内局部变量，使其得不到释放
function bindEvent() 
{ 
    var obj=document.createElement("XXX"); 
    obj.onclick=function(){ 
        //Even if it's a empty function 
    } 
}
上例定义事件回调时，由于是函数内定义函数，并且内部函数--事件回调的引用外暴了，形成了闭包
解决之道，将事件处理函数定义在外部，解除闭包
function bindEvent() 
{ 
    var obj=document.createElement("XXX"); 
    obj.onclick=onclickHandler; 
} 
function onclickHandler(){ 
    //do something 
}
或者在定义事件处理函数的外部函数中，删除对dom的引用（题外，《JavaScript权威指南》中介绍过，闭包中，作用域中没用的属性可以删除，以减少内存消耗。）
function bindEvent() 
{ 
    var obj=document.createElement("XXX"); 
    obj.onclick=function(){ 
        //Even if it's a empty function 
    } 
    obj=null; 
}
为什么闭包会引起内存泄漏
function addNum(){
	var num = 0;
	return function () {
		num++
		console.log(num);
	}
}
addNum()()

内部函数 被 外部函数 包含时，内部函数 会将 外部函数 的局部活动对象添加到自己的作用域链中。而由于 内部匿名函数 的作用域链 在引用 外部包含函数 的活动对象 ，即使addNum执行完毕了，它的活动对象还是不会被销毁！
即，addNum的执行环境作用域链都销毁了，它的活动对象还在内存中留着呢。
并且根据垃圾回收机制，被另一个作用域引用的变量不会被回收。
所以，除非内部的匿名函数解除对活动变量的引用（解除对匿名函数的引用），才可以释放内存。*老浏览器（主要是IE6）由于垃圾回收有问题导致很容易出现内存泄漏，现在的主流浏览器已经不会发生这种问题。
循环引用
许多人对闭包和内存泄露的关系有误解，认为闭包一定会引起内存泄漏，其实是不对的。闭包和内存泄露有关系的地方是，使用闭包的同时比较容易形成循环引用，如果闭包的作用域链中保存着一些DOM节点，这时候就有可能造成内存泄露。这主要是程序员容易引起的bug，不是浏览器的问题。
如果要解决循环引用带来的内存泄露问题，我们只需要把循环引用中的变量设为null即可。将变量设置为null意味着切断变量与它此前引用的值之间的连接。当垃圾收集器下次运行时，就会删除这些值并回收它们占用的内存。